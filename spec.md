# Cover Letter

This is a web application which allows users, currently just one, to manage the life cycle of a cover letter for a job application.
The idea is to send highly customised cover letters to potential employers by leveraging LLM (i.e. Gemini).

## Structure of the application

It will be the usual 3 tier architecture on Docker, deployed on an on-premise infrastructure composed of Raspberry Pis (ARM) running Docker Swarm. Traefik is used as a reverse proxy to handle traffic and provide TLS certificates.

The stack consists of:
- a frontend in Angular served from one or multiple Docker containers.
- a backend in Golang exposing HTTP API with GinTonic, served from one or multiple Docker containers.
- batch workers in Python and Golang to asynchronously process data, in Docker containers.
- a MongoDB database to store the data, still in containerized form.
- a Redis instance to queue emails (OTP and cover letters) and store temporary codes.

### Workflow

#### Scraping recipients and their info

The user can manually insert recipients and companies. Additionally, an async web crawler will scrape emails and information about the recipients and generally of the companies which the recipients belong to. The web crawler uses Google Search to find targets and directly populates the `companies` and `recipients` lists. The user can review and remove irrelevant results later. A dedicated "Crawler Task" interface allows the user to define search parameters; the location can be left empty to rely on IP-based localization.
The web crawler runs regularly (e.g., once a day) with different patterns every time. It operates slowly to remain stealthy and avoid detection.

#### Prepare Cover Letters

After having a base of recipients and their information, asyncronously the system will prepare a cover letter to send for each recipient. The cover letter will be generated by using Gemini (API Key passed as a system-wide environment variable) and providing context of the company, the recipient itself and the user who is applying for the job (their identity to be precise).

#### Refine Cover Letters

The user can use the web application to see and review the cover letters. The user can directly change the cover letter itself or can write a prompt to use again Gemini to alter the cover letter. The system uses the stored `history` and `conversation_id` to maintain context, allowing for refinements without starting fresh.

#### Send Cover Letters

Once the user is satisfied with a cover letter, they can send an email of it to the selected recipient. The email is sent via SMTP (credentials provided via environment variables). Redis is used to queue the emails. The cover letter body is converted from Markdown to HTML by the backend and wrapped in the user-defined HTML template (stored in the Identity) before sending.

### MVP and experiment

Initially the application was developed with a Telegram bot to avoid dealing with the frontend display. Now, we want to implement a full web fronted.

## Structure of the data

The database is currently named `cover_letter`, but will be in the future named after the user in order to have separated instances.
In the DB we have 7 collections:
- `fields`, list of `{'field': 'name of the field/sector which one can operate in'}`, which is the sector/field of a company or worker;
- `companies`, list of `{'name': 'name of the company', 'description': 'description of the company', 'field': 'id of the field/sector which the company operates in'}`;
- `identities`, list of `{'identity': 'id', 'field': 'id of the field/sector which the identity belongs to, 'name': 'visible name of the identity, 'description': 'description of the identity', 'html_template': 'HTML template for the email'}`, which describes the identity of the user who wants to send the cover letter. There is only one identity per field; attempts to create a duplicate identity for a field will be blocked;
- `recipients`, list of `{'email': 'recipient email', 'description': 'description of the recipient', 'name': 'name of the recipient', 'company': 'company which the recipient belongs'}`, which describes the recipient of the cover letter;
- `cover-letters`, list of `{'recipient_id': 'id of the recipient', 'cover_letter': 'body of the cover letter to send', 'created_at': 'timestamp of creation', 'prompt': 'initial prompt to create the cover letter', 'history': 'conversation with AI to recall the context', 'conversation_id': 'Gemini conversation ID to reuse the same conversation', 'updated_at': 'timestamp of last update', 'status': 'status of the letter (e.g., draft, generated, sent)'}`, which describes the cover letters and their processing;
- `crawls`, log of the crawler tasks performed with `start_time`, `error`, `result`;
- `settings`, it will be just one document with the personal setting like the `location` to use in the crawling.

Companies and identities belong to a field/sector in order to associate companines, and respective recipients, with an identity of the user. This is done to be specific for a job regardless the manifold aspects of a person. For example, a person can work in the charity field, but also in fashion. Keeping the identies distinguished allows us to describe the strength of each identity for that specific field.

In the DB there are cross relationships to connect the data via the id of the document (MongoDB jargon):
- `recipients` uses company id in `company` to associate the recipient with a company;
- `cover-letters` is associated with a recipient;
- `companies` is associated with `fields`;
- `identities` is associated with `fields`.

### Redis queues

Redis will be used for:
- queieing emails to send, `emails_queue`;
- store temporary OTP codes `otps` dictionary.

The email queue will be consumed by an async service in GoLang, in its container. It uses SMTP protocol to send emails. In the queue, the email is defined by its:
- body;
- subject;
- sender;
- recipient.

## Frontend 

It is an Angular application styled with Tailwind CSS, using JWT tokens for authentication. By using JWT, we can have multiple backends.

The user interface is a modern, responsive dashboard designed for efficiency and clarity.
- **Navigation**: A persistent side navigation bar provides access to `Recipients`, `Companies`, `Identities`, `Cover Letters`, and `Crawler Tasks`.
- **Entity Management**: `Recipients`, `Companies`, and `Identities` are displayed in interactive lists (Data Tables) supporting sorting and filtering. Inline editing allows for quick updates to fields like names, descriptions, and email HTML templates (for identities) without leaving the context.
- **Cover Letter Studio**: The core workspace features a **split-pane view**. On one side, a rich Markdown editor allows manual crafting; on the other, a live preview renders the final HTML (rendered by the backend to ensure consistency). The list of cover letters supports filtering by status (e.g., Draft, Sent).
  - **AI Integration**: Below the editor, a dedicated "Prompt Bar" allows the user to instruct Gemini to refine or rewrite sections of the letter.
- **Crawler Tasks** panel: it will list the recent tasks performed by the crawler. And the settings, like `location` to use for the crawling. 
- **Feedback & Async Operations**: Since scraping and generation are asynchronous, the UI uses **toast notifications** (snackbars) to alert users when background tasks complete. **Skeleton loaders** are used during data fetching to improve perceived performance.

### Settings

On the top right, a cog icon allows the user to configure settings for their own profile.

## Life cycle of a cover letter

A cover letter starts from a system prompt by using the information about the recipient (e.g. they are a photographer), the company they work for and the identity of the candidate.
The cover letter can be refined by the user by manual edits or further prompts.
If vetted by the user, the cover letter will be sent via email.

## Login

The login will be done with a one time passwrod sent to the email of the user. The user will insert their own email. If the email matches the internal list of emails, the system will send an OTP to the user email. This temporarily code, expiration 5 minutes, will be used to authenticate the user. The allowed list of email will be passed as an environment variable because we're expecting to allow a couple of emails. For the temporarily code, we'll use a Redis instance to store it with an expiration. The OTP email is queued in Redis and sent via the SMTP worker.